# CSR & SSR

## CSR

- 렌더링이 클라이언트 쪽에서 일어남
- 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내주고 클라이언트는 그걸 받아 렌더링 시작

![Untitled](https://user-images.githubusercontent.com/91203029/221329353-5efe7997-6391-4b02-8e00-347d81cc9dce.png)

1. 사용자가 웹사이트에게 요청을 보냄
2. CDN이 HTML파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.
3. 브라우저는 HTML과 JS를 다운 받는데 이 때 사용자는 아무것도 볼 수 없다.
4. 브라우저는 JS를 다운 받는다
5. 다운이 완료된 JS가 실행되고 데이터를 위한 API가 호출 된다. 유저는 placeholder를 보게된다.
6. 서버가 API로부터의 요청에 응답한다.
7. API로부터 받아온 데이터를 placeholder 자리에 넣어준다. 이제 페이지를 조작 가능하다.

**서버에서 처리없이 클라이언트로 보내주기 때문에 자바스크립티가 모두 다운로드 되고 실행 되기 전까지 사용자는 아무것도 볼 수 없다.**

### 장점

- 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아 왔기 때문에 초기 이후 구동 속도가 빠르다
- CSR은 클라이언트에 일감을 몰아주기 때문에 서버 부하가 적다.
- UX가 우수하다

### 단점

- HTML, CSS, 스크립트들을 한 번에 불러와 초기 로딩 시간이 오래 걸린다.
- 초기 HTML 파일이 비어있기 때문에 봇이 데이터 수집하기 어려워 SEO에 좋지않다

## SSR

- 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식

![Untitled 1](https://user-images.githubusercontent.com/91203029/221329361-61676792-470c-4e40-ade4-a8e84f722064.png)

1. 사용자가 웹사이트에게 요청을 보냄
2. 서버는 ‘Ready to Render’ ( 즉시 렌더링 가능한 ) HTML 파일을 만든다
3. 브라우저가 즉시 HTML을 렌더링하지만 조작은 불가능하다 ( Javascript가 읽히기 전 )
4. 브라우저가 Javascript를 다운 받는다.
5. 다운 받아지고 있는 동안 컨텐츠는 볼 수 있지만 조작은 할 수 없다. 이 때 사용자의 조작을 기억하고 있다
6. 브라우저가 Javascript 프레임워크를 실행한다.
7. Javascript까지 성공적으로 컴파일 되었기에 기억하고 있떤 사용자 조작이 실행되고 웹 페이지를 조작할 수 있다.

서버에서 이미 ‘즉시 렌더링 가능한’ 상태로 클라이언트에게 전달하기 때문에 JS가 다운로드 되는 동안 사용자는 어떤 것을 보고 있을 수 있다.

### 장점

- 필요한 부분의 HTML과 스크립트만 불러와 첫번째 페이지 로딩이 빠르다
- UX가 우수하다

### 단점

- Blinking issue가 있다 ( 좋지 않은 UX )
- 매번 서버에 요청하기 때문에 서버 자원을 더 많이 사용한다. 서버에 과부하가 걸리기 쉽다
- 반응이 없는 자바스크립트 ( TTV ≠ TTI )

## Time To View & Time To Interact

### TTV

- 사용자가 웹브라우저에 내용을 볼 수 있는 시점

### TTI

- 사용자가 웹브라우저에서 인터랙션 할 수 있는 시점 ( 조작할 수 있는 시점 )
